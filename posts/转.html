<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1" /><title>(转)费马小定理，积模分解公式，高效幂，快速幂模 及 米勒-拉宾检验</title><meta name="twitter:card" content="summary" /><meta name="twitter:site" content="@" /><meta name="twitter:title" content="(转)费马小定理，积模分解公式，高效幂，快速幂模 及 米勒-拉宾检验" /><meta name="twitter:description" content="The content is recoverd from Wordpress Blog, for more details please check HERE"><meta name="description" content="The content is recoverd from Wordpress Blog, for more details please check HERE"><meta name="google-site-verification" content="epFgX0s_0RM3CdjwFcsewfXzPov2g8s9ZBOLyaIUH-o"><link rel="icon" href="/assets/favicon.png"><link rel="apple-touch-icon" href="/assets/touch-icon.png"><link rel="stylesheet" href="//code.cdn.mozilla.net/fonts/fira.css"><link rel="stylesheet" href="/assets/core.css"><link href="https://cdn.bootcdn.net/ajax/libs/font-awesome/6.1.1/css/all.min.css" rel="stylesheet"><link href="https://cdn.bootcdn.net/ajax/libs/highlight.js/11.5.0/styles/github.min.css" rel="stylesheet"><link rel="canonical" href="/posts/%E8%BD%AC"><link rel="alternate" type="application/atom+xml" title="VOID001's WOWO" href="/feed.xml" /> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','//www.google-analytics.com/analytics.js','ga'); ga( 'create', 'UA-73703130-2', 'auto' ); ga( 'send', 'pageview' ); </script></head><body><aside class="logo"> <a href="/"> <img src="/assets/avatar.jpeg" class="gravatar"> </a> <span class="logo-prompt">Back to Home</span></aside><div class="footer-flex" style="margin-bottom: 4px"> Thinking, Coding, Improving</div><div class="footer-flex" style="color: #333333"> <a href="http://github.com/VOID001"><i class="fa-brands fa-lg fa-github"></i></a> <span style="margin: 4px"></span> <a href="https://t.me/s/void001_fav"><i class="fa-brands fa-lg fa-telegram"></i></a> <span style="margin: 4px"></span> <a href="/feed"><i class="fa-solid fa-lg fa-rss"></i></a></div><script src="https://cdn.bootcdn.net/ajax/libs/font-awesome/6.1.1/js/fontawesome.min.js"></script><main> <noscript><style> article .footnotes { display: block; }</style></noscript><article><div class="center"><h1>(转)费马小定理，积模分解公式，高效幂，快速幂模 及 米勒-拉宾检验</h1><time>December 19, 2014</time> <span>[ ]</span></div><div class="divider"></div><p>The content is recoverd from Wordpress Blog, for more details please check <a href="recover-my-blog">HERE</a></p><h5 id="december-19-2014"><a href="https://web.archive.org/web/20201022010552/https://void-shana.moe/uncategorized/%e8%bd%ac.html" title="9:10 pm">December 19, 2014</a></h5><p><a href="https://web.archive.org/web/20201022010552/https://void-shana.moe/author/void001" title="View all posts by VOID001">VOID001</a> Comments <a href="https://web.archive.org/web/20201022010552/https://void-shana.moe/uncategorized/%e8%bd%ac.html#respond">0 Comment</a></p><p>好文章，整理收藏。<strong>1.费马小定理：</strong></p><p>有N为任意正整数，P为素数，且N不能被P整除（显然N和P互质），则有：</p><p>N^P%P=N(即：N的P次方除以P的余数是N)   或  (N^(P-1))%P=1</p><p><strong>互相变形</strong>：</p><p>原式可化为：</p><p>(N^P-N)%P=0</p><p>(N*(N^(P-1)-1))%P=0</p><p>所以，N*(N^(P-1)-1)是N和P的公倍数</p><p>又因为 N与P互质，而互质数的最小公倍数为它们的乘积</p><p>所以一定存在正整数M使得等式成立：N<em>(N^(P-1)-1)=M</em>N*P</p><p>所以N^(P-1)-1=M*P</p><p>因为M是整数</p><p>所以(N^(P-1)-1)%P=0</p><p>即：</p><p>N^(P-1)%P=1</p><p><strong>2.积模分解公式</strong></p><p><strong>引理，</strong>若：X%Z=0，则(X+Y)%Z=Y%Z</p><p>设有X、Y和Z三个正整数，则必有：(X<em>Y)%Z=((X%Z)</em>(Y%Z))%Z</p><p><strong>证明：</strong></p><p>1.　当X和Y都比Z大时，必有整数A和B使下面的等式成立：</p><p>X=Z*I+A（1）</p><p>Y=Z*J+B（2）除模运算的性质</p><p>将（1）和（2）代入(X*Y)modZ得：</p><p>((Z<em>I+A)(Z</em>J+B))%Z</p><p>所以 (Z<em>(Z</em>I<em>J+I</em>A+I<em>B)+A</em>B)%Z（3）</p><p>所以 Z<em>(Z</em>I<em>J+I</em>A+I*B)能被Z整除</p><p>概据引理，（3）式可化简为：(A*B)%Z</p><p>又因为：A=X%Z，B=Y%Z，代入上式，成为原式右边。</p><p>2.　当X比Z大而Y比Z小时：</p><p>X=Z*I+A</p><p>代入(X*Y)%Z得：</p><p>(Z<em>I</em>Y+A*Y)%Z</p><p>根据引理，转化得：(A*Y)%Z</p><p>因为A=X%Z，又因为Y=Y%Z，代入上式，即得到原式右边。</p><p>同理，当X比Z小而Y比Z大时，原式也成立。</p><p>3.　当X比Z小，且Y也比Z小时，X=X%Z，Y=Y%Z，所以原式成立。</p><p><strong>3.快速乘方算法</strong></p><p>可参见<a href="https://web.archive.org/web/20201022010552/https://www.cnblogs.com/bl4nk/archive/2011/04/20/2022998.html">http://www.cnblogs.com/bl4nk/archive/2011/04/20/2022998.html</a>  中的power函数</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>unsigned Power(unsigned n, unsigned p)  //n^p
{
    unsigned ans = 1;
    while (p &gt; 1)
    {
      if (( p &amp; 1 )!=0)　　ans *= n;
      n *= n; 
      p /= 2;
     }
    return n * ans;
}
</code></pre></div></div><p><strong>4.”蒙格马利”快速幂模算法</strong></p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>\_int64 Montgomery(\_\_int64 n, \_\_int64 p, \_\_int64 m)
{ // 快速计算 (n ^ p) % m 的值，与power算法极类似
    \_\_int64 r = n % m; // 这里的r可不能省
    \_\_int64 k = 1;
    while (p &gt; 1)
    {
        if ((p &amp; 1)!=0)
        {
            k = (k * r) % m; // 直接取模
        }
        r = (r * r) % m; // 同上
        p /= 2;
    }
    return (r * k) % m; // 还是同上 
}
</code></pre></div></div><p><strong>蒙格马利极速版：</strong></p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>unsigned Montgomery(unsigned n,unsigned p,unsigned m)
{ //快速计算(n^p)%m的值
      unsignedk=1;
      n%=m;
     while(p!=1)
     {
         if(0!=(p&amp;1))k=(k*n)%m;
         n=(n*n)%m;
         p&gt;&gt;=1;
    }
    return(n*k)%m;
}
</code></pre></div></div><p><strong>5.素数判断</strong></p><p>根据费马小定理，对于两个互质的素数N和P，必有：N^(P-1)%P=1 <strong>费马测试</strong>  算法思路是这样的：</p><p>对于N，从素数表中取出任意的素数对其进行费马测试，如果取了很多个素数，N仍未测试失败，那么则认为N是素数。当然，测试次数越多越准确，但一般来讲50次就足够了。费马测试并不完全可靠。</p><p>现在我们发现了重要的一点，费马定理是素数的必要条件而非充分条件。这种不是素数，但又能通过费马测试的数字还有不少，数学上把它们称为Carmichael数，现在数学家们已经找到所有10 ^ 16以内的Carmichael数，最大的一个是9585921133193329。我们必须寻找更为有效的测试方法。数学家们通过对费马小定理的研究，并加以扩展，总结出了多种快速有效的素数测试方法，目前最快的算法是米勒-拉宾检验算法。<strong>米勒-拉宾检验</strong> wikipedia : <a href="https://web.archive.org/web/20201022010552/https://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test">Miller–Rabin primality test</a></p><p>米勒-拉宾检验是一个不确定的算法，只能从概率意义上判定一个数可能是素数，测试用的素数表越多，准确率越高，但并不能确保。算法流程如下:</p><p>1.选择T个随机数A，并且有A&lt;N成立。</p><p>2.找到R和M，使得N=2<em>R</em>M+1成立。</p><p>快速得到R和M的方式：N用二进制数B来表示，令C=B-1。因为N为奇数（素数都是奇数），所以C的最低位为0，从C的最低位的0开始向高位统计，一直到遇到第一个1。这时0的个数即为R，M为B右移R位的值。</p><p>3.如果A^M%N=1，则通过A对于N的测试，然后进行下一个A的测试</p><p>4.如果A^M%N!=1，那么令i由0迭代至R，进行下面的测试</p><p>5.如果A^((2^i)*M)%N=N-1则通过A对于N的测试，否则进行下一个i的测试</p><p>6.如果i=r，且尚未通过测试，则此A对于N的测试失败，说明N为合数。</p><p>7.进行下一个A对N的测试，直到测试完指定个数的A</p><p>通过验证得知，当T为素数，并且A是平均分布的随机数，那么测试有效率为1 / ( 4 ^ T )。如果T &gt; 8那么测试失误的机率就会小于10^(-5)，这对于一般的应用是足够了。如果需要求的素数极大，或着要求更高的保障度，可以适当调高T的值。</p><p>下面是代码：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bool RabbinMillerTest( unsigned n ) 
{
    if (n&lt;2)
    { // 小于2的数即不是合数也不是素数
        throw 0;
    }

    const unsigned nPrimeListSize=sizeof(g\_aPrimeList)/sizeof(unsigned);//求素数表元素个数
    for(int i=0;i&lt;nPrimeListSize;++i)
    {// 按照素数表中的数对当前素数进行判断
        if (n/2+1&lt;=g\_aPrimeList[i])
        {// 如果已经小于当前素数表的数，则一定是素数
            return true;
        }
        if (0The content is recoverd from Wordpress Blog, for more details please check [HERE](recover-my-blog)n%g\_aPrimeList[i])
        {// 余数为0则说明一定不是素数
            return false;
        }
    }
    // 找到r和m，使得n = 2^r * m + 1;
    int r = 0, m = n - 1; // ( n - 1 ) 一定是合数
    while ( 0 The content is recoverd from Wordpress Blog, for more details please check [HERE](recover-my-blog) ( m &amp; 1 ) )
    {
        m &gt;&gt;= 1; // 右移一位
        r++; // 统计右移的次数
    }
    const unsigned nTestCnt = 8; // 表示进行测试的次数
    for ( unsigned i = 0; i &lt; nTestCnt; ++i )
    { // 利用随机数进行测试，
        int a = g\_aPrimeList[ rand() % nPrimeListSize ];
        if ( 1 != Montgomery( a, m, n ) )
        {
            int j = 0;
            int e = 1;
            for ( ; j &lt; r; ++j )
            {
                if ( n - 1 The content is recoverd from Wordpress Blog, for more details please check [HERE](recover-my-blog) Montgomery( a, m * e, n ) )
                {
                    break;
                }
                e &lt;&lt;= 1;
            }
            if (j The content is recoverd from Wordpress Blog, for more details please check [HERE](recover-my-blog) r)
            {
                return false;
            }
        }
    }
    return true;
}
</code></pre></div></div><p>在2^31-1以下，有一些伪素数可以通过{2,3,5,7,11}的测试，已知的有 29341 = 13 * 37 * 61 ， 3215031751 = 151 * 751 * 28351</p><hr /><p><a href="https://web.archive.org/web/20201022010552/https://void-shana.moe/category/uncategorized">Uncategorized</a> <a href="https://web.archive.org/web/20201022010552/https://void-shana.moe/tag/c-linux">C. Linux</a>, <a href="https://web.archive.org/web/20201022010552/https://void-shana.moe/tag/kernel">kernel</a>, <a href="https://web.archive.org/web/20201022010552/https://void-shana.moe/tag/laravel">Laravel</a>, <a href="https://web.archive.org/web/20201022010552/https://void-shana.moe/tag/php">PHP</a>, <a href="https://web.archive.org/web/20201022010552/https://void-shana.moe/tag/python">Python</a>, <a href="https://web.archive.org/web/20201022010552/https://void-shana.moe/tag/shell">Shell</a>, <a href="https://web.archive.org/web/20201022010552/https://void-shana.moe/tag/web">Web</a>, <a href="https://web.archive.org/web/20201022010552/https://void-shana.moe/tag/wine">wine</a></p><hr /><h2 id="historical-comments">Historical Comments</h2><p>Post navigation ————— <a href="https://web.archive.org/web/20201022010552/https://void-shana.moe/acmalgo/%e5%bf%ab%e9%80%9f%e5%b9%82%e7%ae%97%e6%b3%95-neu-1391.html">NEXT<br /> 快速幂算法 NEU 1391</a> <a href="https://web.archive.org/web/20201022010552/https://void-shana.moe/%e6%96%87%e7%ab%a0%e8%bd%ac%e8%bd%bd/%e8%bd%ac-35-best-places-to-learn-how-to-code-quickly.html">PREVIOUS [转] 35 BEST PLACES TO LEARN HOW TO CODE QUICKLY</a></p><script src="https://giscus.app/client.js" data-repo="VOID001/VOID001.github.io" data-repo-id="MDEwOlJlcG9zaXRvcnkzMzI0MDI4NQ==" data-category="Announcements" data-category-id="DIC_kwDOAfs03c4COSSU" data-mapping="pathname" data-reactions-enabled="1" data-emit-metadata="1" data-input-position="top" data-theme="light" data-lang="en" data-loading="lazy" crossorigin="anonymous" async> </script></article><div class="back"> <a href="/">Back</a></div><script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/11.5.0/highlight.min.js"></script> <script>hljs.highlightAll();</script></main></body></html>