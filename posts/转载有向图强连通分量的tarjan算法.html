<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1" /><title>(转载)有向图强连通分量的Tarjan算法</title><meta name="twitter:card" content="summary" /><meta name="twitter:site" content="@" /><meta name="twitter:title" content="(转载)有向图强连通分量的Tarjan算法" /><meta name="twitter:description" content="The content is recoverd from Wordpress Blog, for more details please check HERE"><meta name="description" content="The content is recoverd from Wordpress Blog, for more details please check HERE"><meta name="google-site-verification" content="epFgX0s_0RM3CdjwFcsewfXzPov2g8s9ZBOLyaIUH-o"><link rel="icon" href="/assets/favicon.png"><link rel="apple-touch-icon" href="/assets/touch-icon.png"><link rel="stylesheet" href="//code.cdn.mozilla.net/fonts/fira.css"><link rel="stylesheet" href="/assets/core.css"><link href="https://cdn.bootcdn.net/ajax/libs/font-awesome/6.1.1/css/all.min.css" rel="stylesheet"><link href="https://cdn.bootcdn.net/ajax/libs/highlight.js/11.5.0/styles/github.min.css" rel="stylesheet"><link rel="canonical" href="/posts/%E8%BD%AC%E8%BD%BD%E6%9C%89%E5%90%91%E5%9B%BE%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F%E7%9A%84tarjan%E7%AE%97%E6%B3%95"><link rel="alternate" type="application/atom+xml" title="VOID001's WOWO" href="/feed.xml" /> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','//www.google-analytics.com/analytics.js','ga'); ga( 'create', 'UA-73703130-2', 'auto' ); ga( 'send', 'pageview' ); </script></head><body><aside class="logo"> <a href="/"> <img src="/assets/avatar.jpeg" class="gravatar"> </a> <span class="logo-prompt">Back to Home</span></aside><div class="footer-flex" style="margin-bottom: 4px"> Thinking, Coding, Improving</div><div class="footer-flex" style="color: #333333"> <a href="http://github.com/VOID001"><i class="fa-brands fa-lg fa-github"></i></a> <span style="margin: 4px"></span> <a href="https://t.me/s/void001_fav"><i class="fa-brands fa-lg fa-telegram"></i></a> <span style="margin: 4px"></span> <a href="/feed"><i class="fa-solid fa-lg fa-rss"></i></a></div><script src="https://cdn.bootcdn.net/ajax/libs/font-awesome/6.1.1/js/fontawesome.min.js"></script><main> <noscript><style> article .footnotes { display: block; }</style></noscript><article><div class="center"><h1>(转载)有向图强连通分量的Tarjan算法</h1><time>May 7, 2015</time> <span>[ ]</span></div><div class="divider"></div><p>The content is recoverd from Wordpress Blog, for more details please check <a href="recover-my-blog">HERE</a></p><h5 id="may-7-2015"><a href="https://web.archive.org/web/20210419004250/https://void-shana.moe/acmalgo/%e8%bd%ac%e8%bd%bd%e6%9c%89%e5%90%91%e5%9b%be%e5%bc%ba%e8%bf%9e%e9%80%9a%e5%88%86%e9%87%8f%e7%9a%84tarjan%e7%ae%97%e6%b3%95.html" title="8:59 am">May 7, 2015</a></h5><p><a href="https://web.archive.org/web/20210419004250/https://void-shana.moe/author/void001" title="View all posts by VOID001">VOID001</a> Comments <a href="https://web.archive.org/web/20210419004250/https://void-shana.moe/acmalgo/%e8%bd%ac%e8%bd%bd%e6%9c%89%e5%90%91%e5%9b%be%e5%bc%ba%e8%bf%9e%e9%80%9a%e5%88%86%e9%87%8f%e7%9a%84tarjan%e7%ae%97%e6%b3%95.html#respond">0 Comment</a></p><h3 id="转自httpswwwbyvoidcomblogscc-tarjan">转自:<a href="https://web.archive.org/web/20210419004250/https://www.byvoid.com/blog/scc-tarjan">https://www.byvoid.com/blog/scc-tarjan</a></h3><h3 id="有向图强连通分量"><strong>[有向图强连通分量]</strong></h3><p>在有向图G中，如果两个顶点间至少存在一条路径，称两个顶点<strong>强连通</strong>(strongly connected)。如果有向图G的每两个顶点都强连通，称G是一个<strong>强连通图</strong>。非强连通图有向图的极大强连通子图，称为<strong>强连通分量</strong>(strongly connected components)。</p><p>下图中，子图{1,2,3,4}为一个强连通分量，因为顶点1,2,3,4两两可达。{5},{6}也分别是两个强连通分量。</p><p><a href="https://web.archive.org/web/20210419004250/https://www.byvoid.com/upload/wp/2009/04/image1.png"><img src="https://web.archive.org/web/20210419004250im_/https://www.byvoid.com/upload/wp/2009/04/image1.png" alt="image" title="image" /></a></p><p>直接根据定义，用双向遍历取交集的方法求强连通分量，时间复杂度为O(N^2+M)。更好的方法是Kosaraju算法或Tarjan算法，两者的时间复杂度都是O(N+M)。本文介绍的是Tarjan算法。</p><h3 id="tarjan算法"><strong>[Tarjan算法]</strong></h3><p>Tarjan算法是基于对图深度优先搜索的算法，每个强连通分量为搜索树中的一棵子树。搜索时，把当前搜索树中未处理的节点加入一个堆栈，回溯时可以判断栈顶到栈中的节点是否为一个强连通分量。</p><p>定义DFN(u)为节点u搜索的次序编号(时间戳)，Low(u)为u或u的子树能够追溯到的最早的栈中节点的次序号。由定义可以得出，</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Low(u)=Min
{
    DFN(u),
    Low(v),(u,v)为树枝边，u为v的父节点
    DFN(v),(u,v)为指向栈中节点的后向边(非横叉边)
}
</code></pre></div></div><p>当DFN(u)=Low(u)时，以u为根的搜索子树上所有节点是一个强连通分量。</p><p>算法伪代码如下</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tarjan(u)
{
    DFN[u]=Low[u]=++Index                      // 为节点u设定次序编号和Low初值
    Stack.push(u)                              // 将节点u压入栈中
    for each (u, v) in E                       // 枚举每一条边
        if (v is not visted)               // 如果节点v未被访问过
            tarjan(v)                  // 继续向下找
            Low[u] = min(Low[u], Low[v])
        else if (v in S)                   // 如果节点v还在栈内
            Low[u] = min(Low[u], DFN[v])
    if (DFN[u] The content is recoverd from Wordpress Blog, for more details please check [HERE](recover-my-blog) Low[u])                      // 如果节点u是强连通分量的根
        repeat
            v = S.pop                  // 将v退栈，为该强连通分量中一个顶点
            print v
        until (uThe content is recoverd from Wordpress Blog, for more details please check [HERE](recover-my-blog) v)
}
</code></pre></div></div><p>接下来是对算法流程的演示。</p><p>从节点1开始DFS，把遍历到的节点加入栈中。搜索到节点u=6时，DFN[6]=LOW[6]，找到了一个强连通分量。退栈到u=v为止，{6}为一个强连通分量。</p><p><a href="https://web.archive.org/web/20210419004250/https://www.byvoid.com/upload/wp/2009/04/image2.png"><img src="https://web.archive.org/web/20210419004250im_/https://www.byvoid.com/upload/wp/2009/04/image2.png" alt="image" title="image" /></a></p><p>返回节点5，发现DFN[5]=LOW[5]，退栈后{5}为一个强连通分量。</p><p><a href="https://web.archive.org/web/20210419004250/https://www.byvoid.com/upload/wp/2009/04/image3.png"><img src="https://web.archive.org/web/20210419004250im_/https://www.byvoid.com/upload/wp/2009/04/image3.png" alt="image" title="image" /></a></p><p>返回节点3，继续搜索到节点4，把4加入堆栈。发现节点4向节点1有后向边，节点1还在栈中，所以LOW[4]=1。节点6已经出栈，(4,6)是横叉边，返回3，(3,4)为树枝边，所以LOW[3]=LOW[4]=1。</p><p><a href="https://web.archive.org/web/20210419004250/https://www.byvoid.com/upload/wp/2009/04/image4.png"><img src="https://web.archive.org/web/20210419004250im_/https://www.byvoid.com/upload/wp/2009/04/image4.png" alt="image" title="image" /></a></p><p>继续回到节点1，最后访问节点2。访问边(2,4)，4还在栈中，所以LOW[2]=DFN[4]=5。返回1后，发现DFN[1]=LOW[1]，把栈中节点全部取出，组成一个连通分量{1,3,4,2}。</p><p><a href="https://web.archive.org/web/20210419004250/https://www.byvoid.com/upload/wp/2009/04/image5.png"><img src="https://web.archive.org/web/20210419004250im_/https://www.byvoid.com/upload/wp/2009/04/image5.png" alt="image" title="image" /></a></p><p>至此，算法结束。经过该算法，求出了图中全部的三个强连通分量{1,3,4,2},{5},{6}。</p><p>可以发现，运行Tarjan算法的过程中，每个顶点都被访问了一次，且只进出了一次堆栈，每条边也只被访问了一次，所以该算法的时间复杂度为O(N+M)。</p><p>求有向图的强连通分量还有一个强有力的算法，为Kosaraju算法。Kosaraju是基于对有向图及其逆图两次DFS的方法，其时间复杂度也是O(N+M)。与Trajan算法相比，Kosaraju算法可能会稍微更直观一些。但是Tarjan只用对原图进行一次DFS，不用建立逆图，更简洁。在实际的测试中，Tarjan算法的运行效率也比Kosaraju算法高30%左右。此外，该Tarjan算法与<a href="https://web.archive.org/web/20210419004250/https://www.byvoid.com/blog/biconnect/">求无向图的双连通分量(割点、桥)的Tarjan算法</a>也有着很深的联系。学习该Tarjan算法，也有助于深入理解求双连通分量的Tarjan算法，两者可以类比、组合理解。</p><p>求有向图的强连通分量的Tarjan算法是以其发明者<a href="https://web.archive.org/web/20210419004250/https://en.wikipedia.org/wiki/Robert_Tarjan">Robert Tarjan</a>命名的。Robert Tarjan还发明了求<a href="https://web.archive.org/web/20210419004250/https://www.byvoid.com/blog/biconnect/">双连通分量</a>的Tarjan算法，以及求最近公共祖先的离线Tarjan算法，在此对Tarjan表示崇高的敬意。</p><p>附：tarjan算法的C++程序</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void tarjan(int i)
{
    int j;
    DFN[i]=LOW[i]=++Dindex;
    instack[i]=true;
    Stap[++Stop]=i;
    for (edge *e=V[i];e;e=e-&gt;next)
    {
        j=e-&gt;t;
        if (!DFN[j])
        {
            tarjan(j);
            if (LOW[j]&lt;LOW[i])
                LOW[i]=LOW[j];
        }
        else if (instack[j] &amp;&amp; DFN[j]&lt;LOW[i])
            LOW[i]=DFN[j];
    }
    if (DFN[i]The content is recoverd from Wordpress Blog, for more details please check [HERE](recover-my-blog)LOW[i])
    {
        Bcnt++;
        do
        {
            j=Stap[Stop--];
            instack[j]=false;
            Belong[j]=Bcnt;
        }
        while (j!=i);
    }
}
void solve()
{
    int i;
    Stop=Bcnt=Dindex=0;
    memset(DFN,0,sizeof(DFN));
    for (i=1;i&lt;=N;i++)
        if (!DFN[i])
            tarjan(i);
}
</code></pre></div></div><p> </p><p><strong>[参考资料]</strong></p><ul><li><a href="https://web.archive.org/web/20210419004250/https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm" title="http://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm">Wikipedia</a></li><li><a href="https://web.archive.org/web/20210419004250/http://adn.cn/">Amber</a>的图论总结</li></ul><p> </p><hr /><p><a href="https://web.archive.org/web/20210419004250/https://void-shana.moe/category/acmalgo">ACM Algorithm</a>, <a href="https://web.archive.org/web/20210419004250/https://void-shana.moe/category/acmalgo/graphtheory">GraphTheory</a> <a href="https://web.archive.org/web/20210419004250/https://void-shana.moe/tag/c-linux">C. Linux</a>, <a href="https://web.archive.org/web/20210419004250/https://void-shana.moe/tag/kernel">kernel</a>, <a href="https://web.archive.org/web/20210419004250/https://void-shana.moe/tag/laravel">Laravel</a>, <a href="https://web.archive.org/web/20210419004250/https://void-shana.moe/tag/php">PHP</a>, <a href="https://web.archive.org/web/20210419004250/https://void-shana.moe/tag/python">Python</a>, <a href="https://web.archive.org/web/20210419004250/https://void-shana.moe/tag/shell">Shell</a>, <a href="https://web.archive.org/web/20210419004250/https://void-shana.moe/tag/web">Web</a>, <a href="https://web.archive.org/web/20210419004250/https://void-shana.moe/tag/wine">wine</a></p><hr /><h2 id="historical-comments">Historical Comments</h2><p>Post navigation ————— <a href="https://web.archive.org/web/20210419004250/https://void-shana.moe/robocode/robocode-%e5%ad%a6%e4%b9%a0-bothelloworld.html">NEXT<br /> [Robocode 学习] botHelloWorld</a> <a href="https://web.archive.org/web/20210419004250/https://void-shana.moe/uncategorized/hdu-5178-bc31-a-pairs-%e4%ba%8c%e5%88%86%e4%bc%98%e5%8c%96%e6%97%b6%e9%97%b4%e5%a4%8d%e6%9d%82%e5%ba%a6.html">PREVIOUS [HDU 5178 ,BC#31 A] Pairs 二分优化时间复杂度</a></p><script src="https://giscus.app/client.js" data-repo="VOID001/VOID001.github.io" data-repo-id="MDEwOlJlcG9zaXRvcnkzMzI0MDI4NQ==" data-category="Announcements" data-category-id="DIC_kwDOAfs03c4COSSU" data-mapping="pathname" data-reactions-enabled="1" data-emit-metadata="1" data-input-position="top" data-theme="light" data-lang="en" data-loading="lazy" crossorigin="anonymous" async> </script></article><div class="back"> <a href="/">Back</a></div><script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/11.5.0/highlight.min.js"></script> <script>hljs.highlightAll();</script></main></body></html>